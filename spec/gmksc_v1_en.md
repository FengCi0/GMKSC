# üìò GMK-SC v1 English Specification Document


## 1. Overview

**GMK-SC (Graph Marker-KEM Stream Cipher)** is an **asymmetric stream cipher** based on the **Graph Isomorphism (GI) problem**.  
It treats graph structures as the key space, establishes encrypted channels through a **node-level public-private key system (Marker-KEM)**, and generates keystreams using **random walks** on graphs, achieving high security and quantum-resistant communication mechanisms.

Algorithm Name: **GMK-SC (Graph Marker-KEM Stream Cipher)**  
Version: **v1.0 (Draft)**  
Release Date: 2025-11-01  

---

## 2. Core Concepts

The security of GMK-SC is built on two main hard problems:

1. **Graph Isomorphism (GI) Problem**: Given two graphs G‚ÇÅ and G‚ÇÇ, determining whether they are isomorphic is an NP problem with no known polynomial-time algorithm. GMK-SC uses isomorphic relationships as a key trapdoor.
2. **Pseudo-Random Walk Keystream (PRW Keystream)**: Performs deterministic random walks on graphs based on node degrees and structure, generating encryption streams bound to the key.

By combining GI with the KEM mechanism, GMK-SC only requires the public key graph G_pub for encryption, while decryption requires the private key graph G_priv and its mapping œÄ‚Åª¬π, thus achieving asymmetric security.

---

## 3. Algorithm Structure

### 3.1 Key Generation (KeyGen)

Input: Number of nodes `n`, edge generation probability `p`  
Output: `(PublicKey, PrivateKey)`

Process:
1. Generate a random graph **G‚ÇÄ(V, E)**.  
2. Generate a random permutation **œÄ: V ‚Üí V'**, and compute **G_pub = œÄ(G‚ÇÄ)**.  
3. Generate a node-level key pair for each node:  
   `MarkerKEM.KeyGen()` ‚Üí (pk·µ¢, sk·µ¢)
4. Public key: `{G_pub, {pk·µ¢}}`  
   Private key: `{G‚ÇÄ, {sk·µ¢}, œÄ‚Åª¬π}`

---

### 3.2 Encryption (Encaps + Encrypt)

Input: Public key graph G_pub, plaintext M, random salt S.  
Output: Ciphertext C = {Enc_KEM, Ciphertext, Salt, StartNode}

Process:
1. Calculate the starting node index using salt S and plaintext length L:  
   `start = H(S || L) mod |V(G_pub)|`
2. Perform KEM encapsulation at the starting node:  
   `(Enc_KEM, k) = MarkerKEM.Encaps(pk_start)`
3. Use k as the seed to perform a pseudo-random walk on the graph:  
   `degrees = Walk(G_pub, start, len(M), seed=k)`
4. Derive the keystream from the degree sequence:  
   `keystream = Hash(k || degrees)`
5. Encrypt:  
   `C‚Çú = M ‚äï keystream`

Final output:
```
C = {
  Enc_KEM: Encrypted encapsulation result,
  Salt: Salt value,
  StartNode: Starting node index,
  Ciphertext: Ciphertext byte stream
}
```

---

### 3.3 Decryption (Decaps + Decrypt)

Input: Private key `{G‚ÇÄ, œÄ‚Åª¬π, {sk·µ¢}}`, received C.  
Output: Plaintext M.

Process:
1. Calculate the starting node index in G‚ÇÄ using œÄ‚Åª¬π.  
2. Decapsulate using the corresponding sk_start to recover the session key:  
   `k = MarkerKEM.Decaps(sk_start, Enc_KEM)`
3. Repeat the same random walk to generate the degree sequence:  
   `degrees = Walk(G‚ÇÄ, start, len(C‚Çú), seed=k)`
4. Reconstruct the keystream and decrypt:  
   `M = C‚Çú ‚äï Hash(k || degrees)`

---

## 4. Notation

| Symbol | Meaning |
|--------|---------|
| G‚ÇÄ | Private Graph |
| G_pub | Public Graph |
| œÄ | Graph isomorphism permutation function |
| œÄ‚Åª¬π | Inverse permutation (recovers isomorphic relationship) |
| pk·µ¢ / sk·µ¢ | Public/private key of the i-th node |
| Enc_KEM | Node-level key encapsulation result |
| k | Session Key |
| S | Random salt |
| degrees | Node degree sequence generated by random walk |
| keystream | Keystream (generated from k and degrees) |

---

## 5. Security Analysis

1. **Asymmetric Security Guarantee**: Decryption requires œÄ‚Åª¬π and node private keys, which cannot be derived from G_pub.  
2. **Enhanced Randomness**: Salt + PRNG seed ensures ciphertext uniqueness.  
3. **Quantum Resistance Potential**: The complexity of the GI problem is higher than number-theoretic problems (RSA/ECC).  
4. **Irreversibility**: Cannot reverse from keystream back to k or graph structure.  

---

## 6. Performance and Applications

- Node count `n ‚âà 100‚Äì500` can generate keys in milliseconds.  
- Extensible to AEAD mode (e.g., ChaCha20-Poly1305).  
- Applicable to post-quantum secure communication, distributed key management, blockchain signature protocols, etc.

---

## 7. Future Directions

- Improve graph structure selection (support regular graphs and random geometric graphs).  
- Implement hash-based graph mapping collision prevention mechanisms.  
- Research provable security models (IND-CCA security).  
- Release GMK-SC v2 with quantum-resistant signature modules.

---

## 8. Reference Implementation

Python reference implementation: `src/gmksc/` directory  
Run example:
```bash
python -m gmksc.demo
```

Output:
```
=== GMK-SC Demo ===
Salt: e08a215290332774
Start node: 19
Session key: fa97...d26e
Ciphertext: e39754d2a9c6aee9...
Recovered plaintext: Hello Graph Cipher!
```

---

## 9. License

GMK-SC is open source under the **Apache License 2.0**.  
Copyright ¬© 2025 GMK-SC Research Group.

